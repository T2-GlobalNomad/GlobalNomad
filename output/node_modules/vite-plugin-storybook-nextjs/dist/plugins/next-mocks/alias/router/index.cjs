'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var test = require('@storybook/test');
var singletonRouter = require('next/dist/client/router.js');
var previewErrors = require('storybook/internal/preview-errors');
var router = require('next/dist/client/router');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var singletonRouter__namespace = /*#__PURE__*/_interopNamespace(singletonRouter);

// src/plugins/next-mocks/alias/router/index.ts
var defaultRouterState = {
  route: "/",
  asPath: "/",
  basePath: "/",
  pathname: "/",
  query: {},
  isFallback: false,
  isLocaleDomain: false,
  isReady: true,
  isPreview: false
};
var routerAPI;
var createRouter = (overrides) => {
  const routerActions = {
    push: test.fn((..._args) => {
      return Promise.resolve(true);
    }).mockName("next/router::useRouter().push"),
    replace: test.fn((..._args) => {
      return Promise.resolve(true);
    }).mockName("next/router::useRouter().replace"),
    reload: test.fn((..._args) => {
    }).mockName(
      "next/router::useRouter().reload"
    ),
    back: test.fn((..._args) => {
    }).mockName(
      "next/router::useRouter().back"
    ),
    forward: test.fn(() => {
    }).mockName("next/router::useRouter().forward"),
    prefetch: test.fn((..._args) => {
      return Promise.resolve();
    }).mockName("next/router::useRouter().prefetch"),
    beforePopState: test.fn((..._args) => {
    }).mockName(
      "next/router::useRouter().beforePopState"
    )
  };
  const routerEvents = {
    on: test.fn((..._args) => {
    }).mockName(
      "next/router::useRouter().events.on"
    ),
    off: test.fn((..._args) => {
    }).mockName(
      "next/router::useRouter().events.off"
    ),
    emit: test.fn((..._args) => {
    }).mockName(
      "next/router::useRouter().events.emit"
    )
  };
  if (overrides) {
    for (const key of Object.keys(routerActions)) {
      if (key in overrides) {
        routerActions[key] = test.fn((...args) => {
          return overrides[key](...args);
        }).mockName(`useRouter().${key}`);
      }
    }
  }
  if (overrides?.events) {
    for (const key of Object.keys(routerEvents)) {
      if (key in routerEvents) {
        routerEvents[key] = test.fn((...args) => {
          return overrides.events[key](...args);
        }).mockName(`useRouter().events.${key}`);
      }
    }
  }
  routerAPI = {
    ...defaultRouterState,
    ...overrides,
    ...routerActions,
    // @ts-expect-error TODO improve typings
    events: routerEvents
  };
  singletonRouter__namespace.default.router = routerAPI;
  for (const cb of singletonRouter__namespace.default.readyCallbacks) {
    cb();
  }
  singletonRouter__namespace.default.readyCallbacks = [];
  return routerAPI;
};
var getRouter = () => {
  if (!routerAPI) {
    throw new previewErrors.NextjsRouterMocksNotAvailable({
      importType: "next/router"
    });
  }
  return routerAPI;
};
var router_default = singletonRouter__namespace.default;
var useRouter2 = test.fn(
  singletonRouter__namespace.useRouter
).mockName("next/router::useRouter");
var withRouter2 = test.fn(singletonRouter__namespace.withRouter).mockName("next/router::withRouter");

exports.createRouter = createRouter;
exports.default = router_default;
exports.getRouter = getRouter;
exports.useRouter = useRouter2;
exports.withRouter = withRouter2;
Object.keys(router).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return router[k]; }
  });
});
